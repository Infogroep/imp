#!/usr/bin/env python

from twisted.internet import reactor, protocol
from twisted.web import server
from twisted.spread import pb
from twisted.web.resource import Resource
from twisted.python import log
from twisted.web.client import FileBodyProducer
from os import path
import os
import subprocess

class Script(Resource):
	isLeaf = True

	def find_suitable_script(self, patharray):
		for i in reversed(range(len(patharray) + 1)):
			potential_path_array = ['scripts'] + patharray[:i]
			remainder_array = patharray[i:]
			potential_path = apply(path.join, potential_path_array)

			if not path.exists(potential_path):
				continue

			if path.isfile(potential_path):
				return (potential_path,remainder_array)

			if path.isdir(potential_path):
				main_path = apply(path.join, potential_path_array + ['main'])

				if not path.exists(main_path):
					continue

				if path.isfile(main_path):
					return (main_path,remainder_array)

		raise BaseException("Unknown script: " + apply(path.join, patharray))

	def render(self, request):
		wrapper_script = path.join(".","script_wrapper")
		(the_script,the_args) = self.find_suitable_script(request.postpath)
		content_type = request.getHeader("Content-Type") or "text/plain"
		requesting_user = request.getHeader("Imp-Requesting-User")

		env = os.environ.copy()
		if not requesting_user is None:
			env["IMP_REQUESTING_USER"] = requesting_user
		
		p = ScriptProtocol(request)
		reactor.spawnProcess(p, 
		                    wrapper_script,
		                    [wrapper_script,the_script,content_type,request.method] + the_args,
		                    env)
		return server.NOT_DONE_YET

"""
Makes sure we don't get already stopped exceptions
"""
class FileBodyProducerWrapper(FileBodyProducer):
	def __init__(self, inputFile):
		FileBodyProducer.__init__(self, inputFile)
		self.alreadyStopped = False

	def setAlreadyStopped(self, arg):
		self.alreadyStopped = True
		return arg

	def startProducing(self, consumer):
		d = FileBodyProducer.startProducing(self, consumer)
		d.addCallback(self.setAlreadyStopped)
		return d

	def stopProducing(self):
		if not self.alreadyStopped:
			FileBodyProducer.stopProducing(self)

class ScriptProtocol(protocol.ProcessProtocol, pb.Viewable):
	got_content_type = False
	content_type = ''
	errortext = ''

	def view_resumeProducing(self, issuer):
		self.resumeProducing()

	def view_pauseProducing(self, issuer):
		self.pauseProducing()

	def view_stopProducing(self, issuer):
		self.stopProducing()

	def resumeProducing(self):
		self.transport.resumeProducing()

	def pauseProducing(self):
		self.transport.pauseProducing()

	def stopProducing(self):
		print "closing output"
		self.transport.closeStdout()
		self.transport.closeStderr()

	def __init__(self, request):
		self.request = request

	def connectionMade(self):
		self.request.registerProducer(self, 1)
		self.request.content.seek(0, 0)
		self.stdinWriter = FileBodyProducerWrapper(self.request.content)

		# Request tries to close my fID when the connection closes. I don't want that.
		self.request.content = None

		whenDone = self.stdinWriter.startProducing(self.transport)
		whenDone.addCallback(self.whenDoneReadingFromStdin)
		self.transport.registerProducer(self.stdinWriter, True)

	def whenDoneReadingFromStdin(self, arg):
		print "closing input"
		self.transport.closeStdin()
		return arg

	def errReceived(self, error):
		self.errortext = self.errortext + error

	def outReceived(self, output):
		if not self.got_content_type:
			newline_loc = output.find('\n')
			if newline_loc == -1:
				self.content_type += output
			else:
				self.content_type += output[:newline_loc]
				self.request.setHeader("Content-Type",self.content_type)
				self.got_content_type = True
				self.request.write(output[newline_loc+1:])
		else:
			self.request.write(output)

	def processEnded(self, reason):
		if reason.value.exitCode != 0:
			log.err("Script %s exited with exit code %s" % (self.request.uri, reason.value.exitCode))
		if self.errortext:
			log.err("Errors from script %s: %s" % (self.request.uri, self.errortext))
		self.request.unregisterProducer()
		self.request.finish()


root = Script()
factory = server.Site(root)
reactor.listenTCP(8080, factory)
reactor.run()
